/*
题目内容：
   在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，
都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室
的手续也不一样。
   面对海量租借教室的信息，我们自然希望编程解决这个问题。我们需要处理接下
来n天的借教室信息，其中第i天学校有ri个教室可供租借。共有m份订单，每份
订单用三个正整数描述，分别为dj,sj,tj，表示某租借者需要从第sj天到第tj天租借
教室（包括第sj天和第tj天），每天需要租借dj个教室。 我们假定，租借者对教室的
大小、地点没有要求。即对于每份订单，我们只需要每天提供dj个教室，而它们具体
是哪些教室，每天是否是相同的教室则不用考虑。
   借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分
配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，
通知当前申请人修改订单。这里的无法满足指从第sj天到第tj天中有至少一天剩余的教
室数量不足dj个。
   现在我们需要知道，是否会有订单无法完全满足。如果有，首先遇到的是哪一个申请人。
   
输入描述

第一行包含两个正整数n,m，表示天数和订单的数量。 
第二行包含n个正整数，其中第i个数为ri，表示第i天可用于租借的教室数量。 
接下来有m行，每行包含三个正整数dj表示租借的数量,sj租借开始天,tj结束天。 
每行相邻的两个数之间均用一个空格隔开。天数与订单均用从1开始的整数编号。

其中有1≤n,m≤10^6,0≤ri,dj≤10^9,1≤sj≤tj≤n。


输出描述

如果所有订单均可满足，则输出只有一行，包含一个整数0。否则输出需要修改订单
的申请人编号(1开始)。


输入样例

4 3 
2 5 4 3
2 1 3 
3 2 4 
4 2 4


输出样例

2

*/

/*
解题思路(二分搜索):
 首先确定上下界: Low = 0, High=M(总订单数) 
 对每个mid = Low + (High - Low) / 2; 确定前mid个人的教室安排是否会产生冲突.
 	如果 会产生冲突 , 则 接下来要到[Low,mid]的订单中去查找那一份最新产生冲突
	如果 不产生冲突, 则 接下来去[mid, High]的订单中去查找最新产生冲突的订单.
	
怎么快速判断是否会产生冲突:
  用差分数组. 如果区间a=[s,t]中的每一个数都是k,如果要把这个区间保存在一个数组c中,则
  只需要做两个动作:
   	1. c[a[s]] += k;
	2. c[a[t+1]] -= k;
  之后的c[ a[s+1,...,t+1] ],都可以通过递推试 c[i] += c[i-1]得到,重要的是,该性质同样
  适用于有多个数组的情况. 即多个数组同时保存在c数组中时, 最后递推出的c[i]是多个数组在
  此处累加的结果
*/

#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int LEN = 1e6+5; //小技巧,避免多写或少写0 
int R[LEN]; //R[i] 表示第i天能提供申请的房间数 
int D[LEN],S[LEN],T[LEN]; //分表保存dj,sj,tj 
int C[LEN]; //差分数组 
int n,m;

//判断前k个人的教室申请安排是否会产生冲突. 
bool judge(int k){
	memset(C,0,sizeof(C));
	//是用差分, 可以将二重循环降为一重循环. 
	for(int i=1;i<=k;++i){
		C[S[i]] += D[i];
		C[T[i]+1] -= D[i];
	}
	//一旦发现某一天的房间数不足就返回0,表示前k个人的安排会产生冲突. 
	//接下来在[Low,mid]中查找 
	for(int i=1;i<=n;++i) if((C[i]+=C[i-1]) > R[i]) return 0;  
	return 1; //返回1表示前k个人的安排不会产生冲突. 接下来去 [Mid+1,High] 中查找 
}

int main(){
#ifdef WFX
freopen("2 in.txt","r",stdin);
#endif
	int dj,sj,tj;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n; ++i) scanf("%d",&R[i]);
	for(int i=1;i<=m;++i) scanf("%d%d%d",&D[i],&S[i],&T[i]);
	//可以首先判断一下所有人全部安排是否会产生冲突. 
	if(judge(m)){
		printf("0");
		return 0;
	}
	//如果会产生冲突, 再进行二分查找. 
	int low=0,high=m,mid;
	while(low<high){
		mid = low + (high-low)/2;
		if(judge(mid)) low = mid+1;
		else high=low;
	}
	printf("%d",high);
	
	return 0;
}
