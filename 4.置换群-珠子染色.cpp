/*
题目内容：
n个珠子绕成一个环，对每个珠子染色，有3种颜色可选。环旋转或者翻转后颜色模式相同的算同一种。
计算共有多少种不同的染色模式。
输入描述
珠子数目n

输出描述
染色模式数

输入样例
4

输出样例
21

*/

/*
解题思路：

Polya定理的应用。先来看Polya定理。
Polya定理：设 G = {a1，a2，…，ag}是 N 个对象的置换群，用 M 种颜色给这 N 个
对象着色，则不同的着色 方案数为：
                  1/|G| * {M^c(a1) + M^c(a2) + … + M^c(ag)}。
其中 c(ai)为置换 ai 的循环节数，( i = 1，2，…，g )。
对于这道题，直接用Polya定理求解，找出所有的置换，并求出置换的循环节数。然后
根据上边公式求出 3^c(ai) 的总和，再除以置换群个数。

题中有两种置换方式:
 
1.旋转置换。

对于旋转，所有的节点都会旋转，所以循环节长度应该是一样的，这个长度是多长呢？
设每次转x格，现在在p号点，走k次后回到p点，即 
	p+kx≡p (%n)
==> kx = 0 (%n) 
所以kx模n等于0，即kx是n的倍数。当然kx还是x的倍数，而k是循环节长度，要取最小,
则满足以上两个条件的最小的kx是lcm(x,n)。把lcm换成gcd:
	kx = nx/gcd(n,x)
==>	k = n/gcd(n,x)
也就是说，循环节长度是n/gcd(x,n)，意义是在每次转x格的前提下，n/gcd(x,n)个数
分别在来回交换。也就是每n/gcd(x,n)个为一组，把n分成好几组,显然分成了gcd(x,n)组,
所以对于旋转，循环节长度n/gcd(x,n),循环节个数gcd(x,n),而每次可以转1步,2步…n步,
所以共有n种置换

2.翻转置换,根据 N 的奇偶性分情况讨论。

奇数：对称轴一定是经过一个点和它的对边，共有n个对称轴，假设对称轴是穿过n节点，
那么在对称中n+1和n-1互换，n+2和n-2互换，这样共有(n-1)/2+1（对称轴穿过的点本身
是一个循环节）个循环节。

偶数： 
分情况讨论对称轴穿过两个点还是两条边。
两条边：n/2个置换，每个置换的循环节个数都是n/2
两个点：n/2个置换，每个置换循环节个数是(n-2)/2+2=n/2+1

最后别忘了除以|G|=n+n/2+n/2=2*n
*/

#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
typedef long long LL;

LL GCD(LL a, LL b){
	while(a&&b) a>b?a=a%b:b=b%a;
	return a+b;
}

int main(){
	LL n,sum=0;
	while( cin>>n && n!=-1){
		if(n==0){ //之前没有考虑0的情况, 导致在poj上ER了两次. 
			printf("0\n");
			continue; 
		} 
		 
		//旋转变换 
		//n种置换，步长为x的置换的循环节有GCD(x,n)个 
		for(int x=1; x<=n; ++x) sum += pow(3, GCD(x,n));
		//翻转变换 
		if(n&1){
			sum += n * pow(3, (n+1)/2); //奇数个珠子，n种翻转方式，每种有(n-1)/2+1个循环节 
		}else{
			sum += n/2 * pow(3, n/2); //旋转轴过两条边,循环节个数是n/2 
			sum += n/2 * pow(3, n/2+1); //旋转轴过两个点 ,循环节个数是(n-2)/2+2
		}
		//最后除以总的置换个数2n 
		sum = sum/2/n;
		cout<<sum<<endl;
		sum = 0;
	} 
	
	return 0;
}
